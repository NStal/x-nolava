// Generated by CoffeeScript 1.10.0
(function() {
  var Ball, Bullet, CameraFacedObject, GameObject, LightGlow, Missile, Ship, WhiteSharp, WhiteSharpExplotion,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  GameObject = (function(superClass) {
    extend(GameObject, superClass);

    function GameObject(mesh) {
      GameObject.__super__.constructor.call(this);
      if (mesh) {
        this.mesh = mesh;
      }
      if (this.mesh) {
        this.mesh.useQuaternion = true;
      }
      this.scale = 1;
      this.position = new Three.Vector3(0, 0, 0);
      this.quaternion = new Three.Quaternion(0, 0, 0, 1);
      this.towards = new Three.Vector3(0, 0, -1);
      this.speed = 0;
      this.turnSpeed = 0;
      this.eulerTurnSpeed = 0.08;
      this.minTurnSpeed = 0.0001;
      this.turnSpeedAccelerator = 0.003;
      this.turnQuaternion = new Three.Quaternion;
      this.isShown = false;
    }

    GameObject.prototype.update = function() {
      var vec3;
      this.towards.set(0, 0, -1);
      this.towards.applyQuaternion(this.quaternion).setLength(this.speed);
      this.position.add(this.towards);
      this.quaternion.multiply(this.turnQuaternion);
      this.turnQuaternion.set(0, 0, 0, 1);
      if (this.relateTarget && this.relateVector) {
        vec3 = this.relateVector.clone();
        vec3.applyQuaternion(this.relateTarget.quaternion);
        this.position.copy(this.relateTarget.position);
        this.position.add(vec3);
      } else if (this.destination) {
        this.moveTo(this.destination);
      }
      if (this.mesh) {
        this.mesh.position.copy(this.position);
        this.mesh.quaternion.copy(this.quaternion);
        return this.mesh.scale.set(this.scale, this.scale, this.scale);
      }
    };

    GameObject.prototype.show = function() {
      this.emit("show");
      if (this.isShown) {
        return;
      }
      GameObject.instances.push(this);
      if (this.mesh) {
        Static.game.scene.add(this.mesh);
      }
      return this.isShown = true;
    };

    GameObject.prototype.hide = function() {
      var i, index, item, len, ref;
      this.emit("hide");
      if (!this.isShown) {
        return;
      }
      if (this.mesh) {
        Static.game.scene.remove(this.mesh);
      }
      this.isShown = false;
      ref = GameObject.instances;
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        item = ref[index];
        if (item === this) {
          GameObject.instances.splice(index, 1);
          return true;
        }
      }
      return false;
    };

    GameObject.prototype.relateTo = function(gobject, distanceVector) {
      console.assert(distanceVector instanceof Three.Vector3);
      this.relateTarget = gobject;
      return this.relateVector = distanceVector;
    };

    GameObject.prototype.forward = function() {};

    GameObject.prototype.moveTo = function(destination) {
      this.turnTo(destination);
      return this.forward();
    };

    GameObject.prototype.turnTo = function(destination) {
      var m1, quaternion, result;
      m1 = new Three.Matrix4();
      m1.lookAt(this.position, destination, this.mesh.up);
      quaternion = new Three.Quaternion().setFromRotationMatrix(m1);
      result = Static.Interpolation(this.quaternion, quaternion, ["x", "y", "z", "w"], this.turnSpeed, true, {});
      this.quaternion.copy(result);
      return this.quaternion.normalize();
    };

    GameObject.prototype.setDestination = function(destination) {
      return this.destination = destination;
    };

    return GameObject;

  })(Leaf.EventEmitter);

  GameObject.instances = [];

  GameObject.update = function() {
    var i, item, len, ref;
    ref = this.instances;
    for (i = 0, len = ref.length; i < len; i++) {
      item = ref[i];
      if (!item) {
        return;
      }
      item.update();
      item.emit("update", item, this);
    }
  };

  Ship = (function(superClass) {
    extend(Ship, superClass);

    function Ship(model) {
      var glow, i, len, mesh, position, positions, sharp;
      this.object = Static.resourceManager.objects[model];
      mesh = new Three.Mesh(this.object.geometry, this.object.material);
      Ship.__super__.constructor.call(this, mesh);
      this.speedVector = new Three.Vector3(0, 0, 0);
      this.speed = 0;
      this.turnSpeed = 0.005;
      this.turnEuler = new Three.Vector3(0, 0, 0);
      this.mesh.useQuaternion = true;
      positions = [];
      positions = [new Three.Vector3(0, 44, 400), new Three.Vector3(60, -42, 400), new Three.Vector3(-60, -42, 400)];
      this.lights = [];
      for (i = 0, len = positions.length; i < len; i++) {
        position = positions[i];
        glow = new LightGlow(600);
        glow.relateTo(this, position);
        sharp = new WhiteSharp(800);
        sharp.relateTo(this, position);
        this.lights.push(glow, sharp);
      }
    }

    Ship.prototype.show = function() {
      var i, len, light, ref, results;
      Ship.__super__.show.call(this);
      ref = this.lights;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        light = ref[i];
        results.push(light.show());
      }
      return results;
    };

    Ship.prototype.hide = function() {
      var i, len, light, ref;
      ref = this.lights;
      for (i = 0, len = ref.length; i < len; i++) {
        light = ref[i];
        light.hide();
      }
      return Ship.__super__.hide.call(this);
    };

    Ship.prototype.turn = function(towards) {
      switch (towards) {
        case "left":
          this.turnEuler.y += this.turnSpeedAccelerator;
          break;
        case "right":
          this.turnEuler.y -= this.turnSpeedAccelerator;
          break;
        case "up":
          this.turnEuler.x += this.turnSpeedAccelerator;
          break;
        case "down":
          this.turnEuler.x -= this.turnSpeedAccelerator;
          break;
        case "none":
          this.turnEuler.x *= 0.8;
          this.turnEuler.y *= 0.8;
      }
      if (Math.abs(this.turnEuler.y) > this.eulerTurnSpeed) {
        this.turnEuler.y = this.eulerTurnSpeed * this.turnEuler.y / Math.abs(this.turnEuler.y);
      }
      if (Math.abs(this.turnEuler.x) > this.eulerTurnSpeed) {
        this.turnEuler.x = this.eulerTurnSpeed * this.turnEuler.x / Math.abs(this.turnEuler.x);
      }
      if (Math.abs(this.turnEuler.y) < this.minTurnSpeed) {
        this.turnEuler.y = 0;
      }
      if (Math.abs(this.turnEuler.x) < this.minTurnSpeed) {
        this.turnEuler.x = 0;
      }
      return this.turnQuaternion.multiply(new Three.Quaternion().setFromEuler(this.turnEuler));
    };

    return Ship;

  })(GameObject);

  Bullet = (function(superClass) {
    extend(Bullet, superClass);

    function Bullet() {
      var mesh;
      this.object = Static.resourceManager.objects["bullet"];
      mesh = new Three.Mesh(this.object.geometry, this.object.material);
      Bullet.__super__.constructor.call(this, mesh);
      this.speed = 1000;
      this.turnSpeed = 0.001;
      this.maxDistance = 1000 * 30;
      this.distance = 0;
    }

    Bullet.prototype.update = function() {
      var explotion;
      this.distance += this.speed;
      if (this.distance >= this.maxDistance) {
        this.hide();
        explotion = new WhiteSharpExplotion();
        explotion.position.copy(this.position);
        return explotion.show();
      } else {
        return Bullet.__super__.update.call(this);
      }
    };

    return Bullet;

  })(GameObject);

  Ball = (function(superClass) {
    extend(Ball, superClass);

    function Ball() {
      var mesh;
      this.object = Static.resourceManager.objects["ball"];
      mesh = new Three.Mesh(this.object.geometry, this.object.material);
      Ball.__super__.constructor.call(this, mesh);
      this.speed = 0;
      this.turnSpeed = 0;
    }

    return Ball;

  })(GameObject);

  CameraFacedObject = (function(superClass) {
    extend(CameraFacedObject, superClass);

    function CameraFacedObject() {
      CameraFacedObject.__super__.constructor.call(this);
    }

    CameraFacedObject.prototype.update = function() {
      this.quaternion.copy(Static.game.camera.quaternion);
      return CameraFacedObject.__super__.update.call(this);
    };

    return CameraFacedObject;

  })(GameObject);

  LightGlow = (function(superClass) {
    extend(LightGlow, superClass);

    function LightGlow(size) {
      var mat;
      console.log("LightGlow");
      LightGlow.__super__.constructor.call(this);
      this.size = size || 600;
      mat = new Three.SpriteMaterial({
        map: Static.resourceManager.textures.trustHifi,
        opacity: 1,
        color: 0x33aaff,
        transparent: true,
        blending: Three.CustomBlending,
        blendSrc: Three.SrcAlphaFactor,
        blendDst: Three.OneFactor,
        useScreenCoordinates: false
      });
      mat.side = Three.DoubleSide;
      this.sprite1 = new Three.Sprite(mat);
      this.sprite2 = new Three.Sprite(mat);
      this.sprite1.rotation = -Math.PI / 2;
      this.sprite2.rotation = Math.PI / 2;
      this.mesh = new Three.Object3D();
      this.mesh.add(this.sprite1);
      this.mesh.add(this.sprite2);
      this.spriteScale = this.size;
      this.position.set(0, 0, 0);
      this.mesh.useQuaternion = true;
    }

    LightGlow.prototype.update = function() {
      LightGlow.__super__.update.call(this);
      this.spriteScale = this.size + 100 * (Math.random() - 0.5);
      this.sprite1.position.x = this.spriteScale * 1.1 / 4;
      this.sprite2.position.x = -this.spriteScale * 1.1 / 4;
      this.sprite1.scale.set(this.spriteScale, this.spriteScale, this.spriteScale);
      return this.sprite2.scale.set(this.spriteScale, this.spriteScale, this.spriteScale);
    };

    return LightGlow;

  })(CameraFacedObject);

  WhiteSharp = (function(superClass) {
    extend(WhiteSharp, superClass);

    function WhiteSharp(size) {
      var mat;
      WhiteSharp.__super__.constructor.call(this);
      this.size = size || 800;
      mat = new Three.SpriteMaterial({
        map: Static.resourceManager.textures.whitesharp,
        opacity: 1,
        color: 0xffffff,
        transparent: true,
        blending: Three.CustomBlending,
        blendSrc: Three.SrcAlphaFactor,
        blendDst: Three.OneFactor,
        useScreenCoordinates: false
      });
      mat.side = Three.DoubleSide;
      this.mesh = new Three.Sprite(mat);
      this.spriteScale = this.size;
      this.position.set(0, 0, 0);
      this.mesh.useQuaternion = true;
    }

    WhiteSharp.prototype.update = function() {
      WhiteSharp.__super__.update.call(this);
      return this.mesh.scale.set(this.spriteScale, this.spriteScale, this.spriteScale);
    };

    return WhiteSharp;

  })(CameraFacedObject);

  Missile = (function(superClass) {
    extend(Missile, superClass);

    function Missile() {
      var glow, i, len, mesh, position, positions, sharp;
      this.object = Static.resourceManager.objects["missile"];
      mesh = new Three.Mesh(this.object.geometry, this.object.material);
      Missile.__super__.constructor.call(this, mesh);
      this.scale = 50;
      this.speed = 0;
      this.turnSpeed = 0.01;
      this.turnEuler = new Three.Vector3(0, 0, 0);
      positions = [new Three.Vector3(0, 0, 255)];
      this.lights = [];
      for (i = 0, len = positions.length; i < len; i++) {
        position = positions[i];
        glow = new LightGlow(200);
        glow.relateTo(this, position);
        sharp = new WhiteSharp(250);
        sharp.relateTo(this, position);
        this.lights.push(glow, sharp);
      }
    }

    Missile.prototype.show = function() {
      var i, len, light, ref, results;
      Missile.__super__.show.call(this);
      ref = this.lights;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        light = ref[i];
        results.push(light.show());
      }
      return results;
    };

    Missile.prototype.hide = function() {
      var i, len, light, ref;
      ref = this.lights;
      for (i = 0, len = ref.length; i < len; i++) {
        light = ref[i];
        light.hide();
      }
      return Missile.__super__.hide.call(this);
    };

    return Missile;

  })(GameObject);

  WhiteSharpExplotion = (function(superClass) {
    extend(WhiteSharpExplotion, superClass);

    function WhiteSharpExplotion(maxSize) {
      var mat;
      WhiteSharpExplotion.__super__.constructor.call(this);
      this.size = 100;
      mat = new Three.SpriteMaterial({
        map: Static.resourceManager.textures.whitesharp,
        opacity: 0.7,
        color: 0xffffff,
        transparent: true,
        blending: Three.CustomBlending,
        blendSrc: Three.SrcAlphaFactor,
        blendDst: Three.OneFactor,
        useScreenCoordinates: false
      });
      mat.side = Three.DoubleSide;
      this.mesh = new Three.Sprite(mat);
      this.spriteScale = this.size;
      this.position.set(0, 0, 0);
      this.mesh.useQuaternion = true;
      this.lowSpeed = 1.03;
      this.fastSpeed = 2;
      this.floor = 30;
      this.max = (maxSize || 800) * (Math.random() + 1) / 2;
      this.min = 1;
      this.delay = 0.9;
      this.expSize = 2;
      this.state = "start";
    }

    WhiteSharpExplotion.prototype.update = function() {
      WhiteSharpExplotion.__super__.update.call(this);
      if (this.state === "start") {
        if (Math.random() < this.delay) {
          return;
        } else {
          this.state = "preIncrease";
        }
      }
      if (this.state === "preIncrease") {
        this.expSize *= this.lowSpeed;
        if (this.expSize > this.floor) {
          this.state = "increase";
        }
      }
      if (this.state === "increase") {
        this.expSize *= this.fastSpeed;
        if (this.expSize > this.max) {
          this.state = "decrease";
        }
      }
      if (this.state === "decrease") {
        this.expSize /= this.fastSpeed;
        if (this.expSize < this.floor) {
          this.state = "preEnd";
        }
      }
      if (this.state === "preEnd") {
        this.expSize /= this.lowSpeed;
        if (this.expSize < this.min) {
          this.state = "remove";
        }
      }
      if (this.state === "remove") {
        this.hide();
      }
      this.spriteScale = this.size * this.expSize;
      return this.mesh.scale.set(this.spriteScale, this.spriteScale, this.spriteScale);
    };

    return WhiteSharpExplotion;

  })(CameraFacedObject);

  Static.Hitables = [];

  Static.GameObject = GameObject;

  Static.Ship = Ship;

  Static.Bullet = Bullet;

  Static.Ball = Ball;

  Static.LightGlow = LightGlow;

  Static.Missile = Missile;

  Static.WhiteSharpExplotion = WhiteSharpExplotion;

}).call(this);
